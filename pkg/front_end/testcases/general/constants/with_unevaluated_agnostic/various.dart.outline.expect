library /*isNonNullableByDefault*/;
//
// Problems in library:
//
// pkg/front_end/testcases/general/constants/with_unevaluated_agnostic/various.dart:27:3: Error: Only static fields can be declared as const.
// Try using 'final' instead of 'const', or adding the keyword 'static'.
//   const bool initialized =
//   ^^^^^
//
// pkg/front_end/testcases/general/constants/with_unevaluated_agnostic/various.dart:22:25: Error: 'lib' can't be used in a constant expression because it's marked as 'deferred' which means it isn't available until loaded.
// Try moving the constant from the deferred library, or removing 'deferred' from the import.
//
// const fromDeferredLib = lib.x;
//                         ^^^
//
// pkg/front_end/testcases/general/constants/with_unevaluated_agnostic/various.dart:14:30: Warning: Operand of null-aware operation '??' has type 'bool' which excludes null.
// const bool nullAwareOnNull = barFromEnvOrNull ?? true;
//                              ^
//
// pkg/front_end/testcases/general/constants/with_unevaluated_agnostic/various.dart:100:34: Error: The argument type 'A' can't be assigned to the parameter type 'T'.
//  - 'A' is from 'pkg/front_end/testcases/general/constants/with_unevaluated_agnostic/various.dart'.
//   const Class.method(T t) : this(-t);
//                                  ^
//
// pkg/front_end/testcases/general/constants/with_unevaluated_agnostic/various.dart:123:27: Error: Optional parameter 'named' should have a default value because its type 'int' doesn't allow null.
// int procedure(int i, {int named}) => i;
//                           ^^^^^
//
import self as self;
import "dart:core" as core;
import "various_lib.dart" as var;
import "dart:_internal" as _in;

import "org-dartlang-testcase:///various_lib.dart" deferred as lib;

typedef F = (core::int, {named: core::int}) → core::int;
class Foo<E extends core::Object? = dynamic> extends core::Object /*hasConstConstructor*/  {
  final field core::bool saved;
  final field core::bool saved2;
  field core::bool initialized;
  final field self::Foo::E% value;
  const constructor •(self::Foo::E% value, {core::bool saved2 = const core::bool::fromEnvironment("foo", defaultValue: self::barFromEnv), core::bool x = const core::bool::fromEnvironment("foo", defaultValue: self::barFromEnv)}) → self::Foo<self::Foo::E%>
    : self::Foo::value = value, self::Foo::saved2 = saved2, self::Foo::saved = x, super core::Object::•()
    ;
}
class A extends core::Object /*hasConstConstructor*/  {
  const constructor •() → self::A
    : super core::Object::•()
    ;
  operator unary-() → self::A
    ;
}
class B extends core::Object implements self::A /*hasConstConstructor*/  {
  const constructor •() → self::B
    : super core::Object::•()
    ;
  operator unary-() → self::B
    ;
}
class C extends core::Object implements self::A /*hasConstConstructor*/  {
  const constructor •() → self::C
    : super core::Object::•()
    ;
  operator unary-() → self::C
    ;
}
class Class<T extends self::A = self::A> extends core::Object /*hasConstConstructor*/  {
  const constructor •(self::Class::T t) → self::Class<self::Class::T>
    : super core::Object::•()
    ;
  const constructor redirect(dynamic t) → self::Class<self::Class::T>
    : this self::Class::•(t as{TypeError,ForDynamic,ForNonNullableByDefault} self::Class::T)
    ;
  const constructor method(self::Class::T t) → self::Class<self::Class::T>
    : this self::Class::•(let final<BottomType> #t1 = invalid-expression "pkg/front_end/testcases/general/constants/with_unevaluated_agnostic/various.dart:100:34: Error: The argument type 'A' can't be assigned to the parameter type 'T'.
 - 'A' is from 'pkg/front_end/testcases/general/constants/with_unevaluated_agnostic/various.dart'.
  const Class.method(T t) : this(-t);
                                 ^" in t.{self::A::unary-}() as{TypeError,ForNonNullableByDefault} <BottomType>)
    ;
}
class Subclass<T extends self::A = self::A> extends self::Class<self::Subclass::T> /*hasConstConstructor*/  {
  const constructor •(dynamic t) → self::Subclass<self::Subclass::T>
    : super self::Class::•(t as{TypeError,ForDynamic,ForNonNullableByDefault} self::Subclass::T)
    ;
}
class ConstClassWithF extends core::Object /*hasConstConstructor*/  {
  final field (core::int, {named: core::int}) → core::int foo;
  const constructor •((core::int, {named: core::int}) → core::int foo) → self::ConstClassWithF
    : self::ConstClassWithF::foo = foo, super core::Object::•()
    ;
}
static const field core::bool barFromEnv = const core::bool::fromEnvironment("bar");
static const field core::bool hasBarEnv = const core::bool::hasEnvironment("bar");
static const field core::bool? barFromEnvOrNull0 = const core::bool::fromEnvironment("bar") ?{core::bool?} true : null;
static const field core::bool barFromEnvOrNull = const core::bool::fromEnvironment("bar", defaultValue: self::barFromEnvOrNull0!);
static const field core::bool notBarFromEnvOrNull = !self::barFromEnvOrNull;
static const field core::bool conditionalOnNull = self::barFromEnvOrNull ?{core::bool} true : false;
static const field core::bool nullAwareOnNull = let final core::bool #t2 = self::barFromEnvOrNull in #t2.{core::Object::==}(null) ?{core::bool} true : #t2;
static const field core::bool andOnNull = self::barFromEnvOrNull && true;
static const field core::bool andOnNull2 = true && self::barFromEnvOrNull;
static const field core::bool orOnNull = self::barFromEnvOrNull || true;
static const field core::bool orOnNull2 = self::barFromEnvOrNull || false;
static const field core::bool orOnNull3 = true || self::barFromEnvOrNull;
static const field core::bool orOnNull4 = false || self::barFromEnvOrNull;
static const field core::int fromDeferredLib = let final dynamic #t3 = CheckLibraryIsLoaded(lib) in var::x;
static const field self::Foo<core::int> x = const self::Foo::•<core::int>(42);
static const field core::bool? y = true;
static const field core::bool z = !self::y!;
static const field core::Object maybeInt = const core::bool::fromEnvironment("foo") ?{core::Object} 42 : true;
static const field core::bool isItInt = self::maybeInt is{ForNonNullableByDefault} core::int ?{core::bool} true : false;
static const field core::Object maybeInt2 = self::z ?{core::Object} 42 : true;
static const field core::bool isItInt2 = self::maybeInt2 is{ForNonNullableByDefault} core::int ?{core::bool} true : false;
static const field core::int? maybeInt3 = self::z ?{core::int?} 42 : null;
static const field core::bool isItInt3 = self::maybeInt3 is{ForNonNullableByDefault} core::int ?{core::bool} true : false;
static const field dynamic listOfNull = const <core::Null?>[null];
static const field core::bool isListOfNull = self::listOfNull is{ForNonNullableByDefault} core::List<core::Null?>;
static const field dynamic listOfInt = const <core::int>[42];
static const field core::bool isListOfInt = self::listOfInt is{ForNonNullableByDefault} core::List<core::int>;
static const field core::bool isList = self::listOfInt is{ForNonNullableByDefault} core::List<dynamic>;
static const field dynamic setOfInt = const <core::int>{42};
static const field core::bool isSetOfInt = self::setOfInt is{ForNonNullableByDefault} core::Set<core::int>;
static const field dynamic mapOfInt = const <core::int, core::int>{42: 42};
static const field core::bool isMapOfInt = self::mapOfInt is{ForNonNullableByDefault} core::Map<core::int, core::int>;
static const field dynamic listOfListOfInt = const <core::List<core::int>>[const <core::int>[42]];
static const field core::bool isListOfListOfInt = self::listOfListOfInt is{ForNonNullableByDefault} core::List<core::List<core::int>>;
static const field dynamic setOfSetOfInt = const <core::Set<core::int>>{const <core::int>{42}};
static const field core::bool isSetOfSetOfInt = self::setOfSetOfInt is{ForNonNullableByDefault} core::Set<core::Set<core::int>>;
static const field dynamic mapOfMapOfInt1 = const <core::Map<core::int, core::int>, core::int>{const <core::int, core::int>{42: 42}: 42};
static const field dynamic mapOfMapOfInt2 = const <core::int, core::Map<core::int, core::int>>{42: const <core::int, core::int>{42: 42}};
static const field core::bool isMapOfMapOfInt1 = self::mapOfMapOfInt1 is{ForNonNullableByDefault} core::Map<core::Map<core::int, core::int>, core::int>;
static const field core::bool isMapOfMapOfInt2 = self::mapOfMapOfInt2 is{ForNonNullableByDefault} core::Map<core::int, core::Map<core::int, core::int>>;
static const field core::Symbol symbolWithUnevaluatedParameter = const _in::Symbol::•(const core::String::fromEnvironment("foo"));
static const field core::Symbol symbolWithInvalidName = const _in::Symbol::•("42");
static const field self::Class<self::B>? c0 = const core::bool::fromEnvironment("x") ?{self::Class<self::B>?} null : const self::Class::redirect<self::B>(const self::C::•());
static const field self::Class<self::A>? c1 = const core::bool::fromEnvironment("x") ?{self::Class<self::A>?} null : const self::Class::method<self::A>(const self::A::•());
static const field self::Subclass<self::B>? c2 = const core::bool::fromEnvironment("x") ?{self::Subclass<self::B>?} null : const self::Subclass::•<self::B>(const self::C::•());
static const field self::Class<self::A>? c3 = const core::bool::fromEnvironment("x") ?{self::Class<self::A>?} null : const self::Class::•<self::A>(const self::A::•());
static const field self::Class<self::B>? c4 = const core::bool::fromEnvironment("x") ?{self::Class<self::B>?} null : const self::Class::redirect<self::B>(const self::B::•());
static const field self::Subclass<self::A>? c5 = const core::bool::fromEnvironment("x") ?{self::Subclass<self::A>?} null : const self::Subclass::•<self::A>(const self::A::•());
static const field self::Subclass<self::B>? c6 = const core::bool::fromEnvironment("x") ?{self::Subclass<self::B>?} null : const self::Subclass::•<self::B>(const self::B::•());
static const field core::Type f = (core::int, {named: core::int}) → core::int;
static field self::ConstClassWithF constClassWithF1;
static const field self::ConstClassWithF constClassWithF2 = const self::ConstClassWithF::•(self::procedure);
static const field core::bool unevaluatedBool = const core::bool::fromEnvironment("foo");
static const field core::bool notUnevaluatedBool = !self::unevaluatedBool;
static const field core::bool? unevaluatedBoolOrNull = const core::bool::fromEnvironment("bar") ?{core::bool?} self::unevaluatedBool : null;
static const field core::bool unevaluatedBoolNotNull = self::unevaluatedBoolOrNull!;
static method procedure(core::int i, {core::int named}) → core::int
  ;
static method main() → dynamic
  ;

library /*isNonNullableByDefault*/;
import self as var;
import "dart:core" as core;

static const field core::int x = 42;
