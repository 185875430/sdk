library /*isNonNullableByDefault*/;
import self as self;
import "dart:core" as core;
import "various_2_lib.dart" as var;

import "org-dartlang-testcase:///various_2_lib.dart" as lib;

typedef F1<invariant T extends core::Object? = dynamic> = (T%) → T%;
typedef F2 = <T extends core::Object? = dynamic>(T%) → T%;
static const field core::Type objectTypeLiteral = core::Object;
static const field (core::int) → core::int partialInstantiation = var::id1<core::int>;
static const field var::Class<core::int> instance = const var::Class::•<core::int>(0);
static const field var::Class<dynamic> instance2 = const var::Class::•<dynamic>(const <core::int>[42]);
static const field core::Type functionTypeLiteral = (dynamic) → dynamic;
static const field core::Type genericFunctionTypeLiteral = <T extends core::Object? = dynamic>(T%) → T%;
static const field core::List<core::int> listLiteral = const <core::int>[0];
static const field core::List<dynamic> listLiteral2 = const <dynamic>[const <core::int>[42]];
static const field core::Set<core::int> setLiteral = const <core::int>{0};
static const field core::Set<dynamic> setLiteral2 = const <dynamic>{const <core::int>[42]};
static const field core::Map<core::int, core::String> mapLiteral = const <core::int, core::String>{0: "foo"};
static const field core::Map<dynamic, dynamic> mapLiteral2 = const <dynamic, dynamic>{const <core::int>[42]: "foo", null: const <core::int>[42]};
static const field core::List<core::int> listConcatenation = self::listLiteral;
static const field core::Set<core::int> setConcatenation = self::setLiteral;
static const field core::Map<core::int, core::String> mapConcatenation = self::mapLiteral;
static const field core::bool objectTypeLiteralIdentical = core::identical(self::objectTypeLiteral, var::objectTypeLiteral);
static const field core::bool partialInstantiationIdentical = core::identical(self::partialInstantiation, var::partialInstantiation);
static const field core::bool instanceIdentical = core::identical(self::instance, var::instance);
static const field core::bool instance2Identical = core::identical(self::instance2, var::instance2);
static const field core::bool functionTypeLiteralIdentical = core::identical(self::functionTypeLiteral, var::functionTypeLiteral);
static const field core::bool genericFunctionTypeLiteralIdentical = core::identical(self::genericFunctionTypeLiteral, var::genericFunctionTypeLiteral);
static const field core::bool listLiteralIdentical = core::identical(self::listLiteral, var::listLiteral);
static const field core::bool listLiteral2Identical = core::identical(self::listLiteral2, var::listLiteral2);
static const field core::bool setLiteralIdentical = core::identical(self::setLiteral, var::setLiteral);
static const field core::bool setLiteral2Identical = core::identical(self::setLiteral2, var::setLiteral2);
static const field core::bool mapLiteralIdentical = core::identical(self::mapLiteral, var::mapLiteral);
static const field core::bool mapLiteral2Identical = core::identical(self::mapLiteral2, var::mapLiteral2);
static const field core::bool listConcatenationIdentical = core::identical(self::listConcatenation, var::listConcatenation);
static const field core::bool setConcatenationIdentical = core::identical(self::setConcatenation, var::setConcatenation);
static const field core::bool mapConcatenationIdentical = core::identical(self::mapConcatenation, var::mapConcatenation);
static method main() → dynamic
  ;
static method test(dynamic expected, dynamic actual) → dynamic
  ;

library /*isNonNullableByDefault*/;
import self as var;
import "dart:core" as core;

typedef F1<invariant T extends core::Object? = dynamic> = (T%) → T%;
typedef F2 = <T extends core::Object? = dynamic>(T%) → T%;
class Class<T extends core::Object? = dynamic> extends core::Object /*hasConstConstructor*/  {
  final field var::Class::T% field;
  const constructor •(var::Class::T% field) → var::Class<var::Class::T%>
    : var::Class::field = field, super core::Object::•()
    ;
}
static const field core::Type objectTypeLiteral = core::Object;
static const field (core::Object?, core::Object?) → core::bool c2 = core::identical;
static const field (core::int) → core::int partialInstantiation = const core::bool::fromEnvironment("foo") ?{(core::int) → core::int} var::id1<core::int> : var::id2<core::int>;
static const field var::Class<core::int> instance = const var::Class::•<core::int>(0);
static const field var::Class<dynamic> instance2 = const var::Class::•<dynamic>(const <core::int>[42]);
static const field core::Type functionTypeLiteral = (dynamic) → dynamic;
static const field core::Type genericFunctionTypeLiteral = <T extends core::Object? = dynamic>(T%) → T%;
static const field core::List<core::int> listLiteral = const <core::int>[0];
static const field core::List<dynamic> listLiteral2 = const <dynamic>[const <core::int>[42]];
static const field core::Set<core::int> setLiteral = const <core::int>{0};
static const field core::Set<dynamic> setLiteral2 = const <dynamic>{const <core::int>[42]};
static const field core::Map<core::int, core::String> mapLiteral = const <core::int, core::String>{0: "foo"};
static const field core::Map<dynamic, dynamic> mapLiteral2 = const <dynamic, dynamic>{const <core::int>[42]: "foo", null: const <core::int>[42]};
static const field core::List<core::int> listConcatenation = var::listLiteral;
static const field core::Set<core::int> setConcatenation = var::setLiteral;
static const field core::Map<core::int, core::String> mapConcatenation = var::mapLiteral;
static method id1<T extends core::Object? = dynamic>(var::id1::T% t) → var::id1::T%
  ;
static method id2<T extends core::Object? = dynamic>(var::id2::T% t) → var::id2::T%
  ;
